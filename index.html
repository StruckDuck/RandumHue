<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Color Reveal App</title>
  <style>
    :root { --vh: 1vh; }

    html, body {
      margin: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background-color: #000;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    #app {
      /* Fill the entire iPad screen reliably */
      position: fixed;
      inset: 0; /* top:0; right:0; bottom:0; left:0 */
      width: 100vw;
      /* Fallback chain: JS var -> legacy 100vh -> modern dynamic viewport units */
      height: calc(var(--vh, 1vh) * 100);
      height: 100vh;
      height: 100dvh;
      height: 100svh;

      display: flex;
      justify-content: center;
      align-items: center;
      transition: background-color 1s ease;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      background-color: black;
    }

    #startBtn {
      z-index: 2;
      padding: 16px 24px;
      border: 2px solid rgba(255,255,255,0.9);
      color: #fff;
      background: rgba(0,0,0,0.35);
      font-size: 18px;
      border-radius: 12px;
      position: relative;
    }

    #left, #right {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 50vw;
      /* Keep overlay height in sync with app */
      height: calc(var(--vh, 1vh) * 100);
      height: 100vh;
      height: 100dvh;
      height: 100svh;
      z-index: 1;
      opacity: 0;              /* fully invisible */
      pointer-events: none;    /* clicks handled on #app */
    }
    #left { left: 0; }
    #right { right: 0; }
  </style>
</head>
<body>
  <div id="app" aria-label="Color Reveal App">
    <button id="startBtn" type="button" aria-label="Start routine">Start</button>
    <div id="left" aria-hidden="true"></div>
    <div id="right" aria-hidden="true"></div>
  </div>

  <script>
    // ---------- Mobile 100vh fix ----------
    function setVH() {
      // Prefer visualViewport.height for iPad Safari to avoid toolbar-induced shrink
      const h = (window.visualViewport && window.visualViewport.height) || window.innerHeight;
      document.documentElement.style.setProperty('--vh', `${h * 0.01}px`);
    }px`);
      } catch (e) {
        document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
      }
    }
    setVH();
    // Update on resize, orientation change, PWA visibility changes, and visualViewport events
    window.addEventListener('resize', setVH, { passive: true });
    window.addEventListener('orientationchange', () => setTimeout(setVH, 100), { passive: true });
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) setTimeout(setVH, 50);
    }, { passive: true });
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', setVH, { passive: true });
    }
    window.addEventListener('orientationchange', () => setTimeout(setVH, 100));
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', setVH);
    }

    const TABLE_COLOR_MAP = {
      1: "Black",
      2: "Blue",
      3: "Green",
      4: "Red",
      5: "White",
      6: "Yellow",
      7: "Purple",
      8: "Orange",
      9: "Grey",
    };

    const INPUT_ORDER = ["Black", "Blue", "Green", "Red"];
    const INPUT_SET = new Set(INPUT_ORDER);
    const RANDOM_COLORS = Object.values(TABLE_COLOR_MAP);

    let tapIndex = 0;
    let previousColor = null;
    let currentColor = "Black";
    let bitsByColor = { Black: null, Blue: null, Green: null, Red: null };
    let decodedColor = null;
    let decodedDecimal = null;

    const app = document.getElementById('app');
    const startBtn = document.getElementById('startBtn');

    function showColor(color) {
      app.style.backgroundColor = color.toLowerCase();
      previousColor = currentColor;
      currentColor = color;
    }

    function getRandomColor(exclude = []) {
      const hardExclusions = new Set(["Pink", ...exclude]);
      const available = RANDOM_COLORS.filter(c => !hardExclusions.has(c) && c !== previousColor);
      const pool = available.length ? available : RANDOM_COLORS.filter(c => c !== previousColor);
      return pool[Math.floor(Math.random() * pool.length)];
    }

    function reset() {
      tapIndex = 0;
      previousColor = null;
      currentColor = "Black";
      bitsByColor = { Black: null, Blue: null, Green: null, Red: null };
      decodedColor = null;
      decodedDecimal = null;
      showColor(getRandomColor(["Purple", ...INPUT_ORDER]));
    }

    function allBitsCaptured() {
      return INPUT_ORDER.every(c => bitsByColor[c] !== null);
    }

    function computeDecode() {
      const orderedBits = INPUT_ORDER.map(c => bitsByColor[c]);
      const reversedBits = orderedBits.slice().reverse();
      const binStr = reversedBits.join('');
      const decimal = parseInt(binStr, 2);
      decodedDecimal = decimal;
      decodedColor = TABLE_COLOR_MAP[decimal] || "Pink";
    }

    function nextColorForTap(idx) {
      if (idx <= 3) return getRandomColor(["Purple", ...INPUT_ORDER]);
      if (idx === 4) return "Purple";
      if (idx >= 5 && idx <= 8) return INPUT_ORDER[idx - 5];
      if (idx === 9) return getRandomColor(["Pink", ...INPUT_ORDER, decodedColor, previousColor]);
      if (idx === 10) return decodedColor || "Pink";
      return getRandomColor([]);
    }

    function maybeRecordBitForCurrentColor(bit) {
      if (INPUT_SET.has(currentColor) && bitsByColor[currentColor] === null) {
        bitsByColor[currentColor] = bit;
        if (allBitsCaptured()) computeDecode();
      }
    }

    function handleTap(side) {
      const bit = side === 'right' ? 1 : 0;
      maybeRecordBitForCurrentColor(bit);
      tapIndex += 1;
      const next = nextColorForTap(tapIndex);
      showColor(next);
      if (tapIndex === 9 && !decodedColor) {
        if (allBitsCaptured()) {
          computeDecode();
        } else {
          decodedColor = "Pink";
          decodedDecimal = null;
        }
      }
    }

    startBtn.addEventListener('click', () => {
      startBtn.style.display = 'none';
      reset();
    });

    const unifiedHandler = (ev) => {
      if (startBtn.style.display !== 'none') return;
      let x = null;
      if (ev.type.startsWith('touch')) {
        const t = ev.touches && ev.touches[0];
        if (!t) return;
        x = t.clientX;
      } else if (ev.type === 'pointerdown' || ev.type === 'mousedown') {
        x = ev.clientX;
      } else {
        return;
      }
      const rect = app.getBoundingClientRect();
      const isLeft = (x - rect.left) < rect.width / 2;
      handleTap(isLeft ? 'left' : 'right');
      ev.preventDefault();
    };

    if (window.PointerEvent) {
      app.addEventListener('pointerdown', unifiedHandler, { passive: false });
    } else {
      app.addEventListener('touchstart', unifiedHandler, { passive: false });
      app.addEventListener('mousedown', unifiedHandler);
    }
  </script>
</body>
</html>
